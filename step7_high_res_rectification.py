"""
Step 7: Generate high resolution orthorectified images for ROI using true orthorectification
"""

import cv2
import numpy as np
from pathlib import Path
from datetime import datetime
from step_base import StepBase
import config
from camera_utils import CameraProjector, PlaneProjector,  create_simple_envelope_grid, rectify_image_true_ortho_global


class HighResRectificationStep(StepBase):
    """Step 7: High resolution true orthorectification for ROI"""
    
    def __init__(self, photos_dir=config.PHOTOS_DIR, output_dir=config.OUTPUT_DIR):
        super().__init__(output_dir)
        self.photos_dir = Path(photos_dir)
        self.painting_sets = [d for d in self.photos_dir.iterdir() if d.is_dir()]
        self.high_res_dir = self.output_dir / 'high_res_rectified'
        self.high_res_dir.mkdir(exist_ok=True)
    
    def get_input_requirements(self):
        """Return required inputs for this step"""
        return [
            "step3_recalculate_positions_results",
            "step4_point_cloud_results",
            "step6_roi_selection_results"
        ]
    
    def get_output_files(self):
        """Return output files generated by this step"""
        outputs = []
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            outputs.extend([
                f"high_res_rectified/{painting_name}_high_res_*.png",
                f"intermediate/high_res_rectification_data_{painting_name}.json"
            ])
        outputs.append("intermediate/step7_high_res_rectification_results.json")
        return outputs

    
    
    
    
    def run(self, **kwargs):
        """
        Generate high resolution orthorectified images for ROI using true orthorectification.
        
        Returns:
            dict: Results containing high resolution rectification data
        """
        self.log_step("Step 7: High resolution true orthorectification for ROI")
        
        # Load global reconstructions from Step 3
        step3_results = self.load_result("step3_recalculate_positions_results")
        if not step3_results:
            print("[ERROR] Step 3 results not found. Please run Step 3 first.")
            return None
        
        global_reconstructions = step3_results.get('global_reconstructions', {})
        global_camera_params = step3_results.get('global_camera_params')
        
        if not global_reconstructions:
            print("[ERROR] No global reconstructions found in Step 3 results.")
            return None
        
        # Load point cloud data from Step 4
        step4_results = self.load_result("step4_point_cloud_results")
        if not step4_results:
            print("[ERROR] Step 4 results not found. Please run Step 4 first.")
            return None
        
        point_cloud_data = step4_results.get('point_cloud_data', {})
        
        # Load ROI selections from Step 6
        step6_results = self.load_result("step6_roi_selection_results")
        if not step6_results:
            print("[ERROR] Step 6 results not found. Please run Step 6 first.")
            return None
        
        roi_selections = step6_results.get('roi_selections', {})
        
        high_res_results = {}
        
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            print(f"High resolution true orthorectification for painting {painting_name}")
            
            
            # Get reconstruction data
            reconstruction_data = global_reconstructions.get(painting_name)
            if not reconstruction_data:
                print(f"[ERROR] No reconstruction data found for {painting_name}")
                continue
            
            # Get point cloud data for plane information
            point_cloud_info = point_cloud_data.get(painting_name, {})
            plane_data = point_cloud_info.get('plane_data', {})
            
            # Get ROI selection
            roi_data = roi_selections.get(painting_name)
            if not roi_data:
                print(f"[ERROR] No ROI selection found for {painting_name}")
                continue
            
            roi_bounds_plane = roi_data.get('roi_bounds_plane', {})
            if not roi_bounds_plane:
                print(f"[ERROR] No ROI plane bounds found for {painting_name}")
                continue
            
            # Create camera projector with global calibration
            camera_projector = CameraProjector(global_camera_params)
            
            # Create plane projector ONCE for the entire painting
            plane_normal = np.array(plane_data.get('plane_normal', [0, 0, 1]))
            plane_center = np.array(plane_data.get('plane_center', [0, 0, 0]))
            plane_projector = PlaneProjector(plane_normal, plane_center)
            
            # Get image files
            image_files = list(painting_set.glob('*.jpg')) + list(painting_set.glob('*.jpeg')) + list(painting_set.glob('*.png'))
            
            if not image_files:
                print(f"[ERROR] No image files found for {painting_name}")
                continue
            
            # Get camera poses from reconstruction
            images_data = reconstruction_data.get('images', {})
            
            # Create global high-resolution grid for ROI area ONCE
            target_resolution = config.HIGH_RES_GRID_SIZE
            
            # Extract ROI bounds
            u_min = roi_bounds_plane['u_min']
            u_max = roi_bounds_plane['u_max']
            v_min = roi_bounds_plane['v_min']
            v_max = roi_bounds_plane['v_max']

            # Create the four corner points of the ROI rectangle
            all_corners_2d = [
                [u_min, v_min],  # Bottom-left corner
                [u_max, v_min],  # Bottom-right corner
                [u_max, v_max],  # Top-right corner
                [u_min, v_max]   # Top-left corner
            ]
            # Create tight fit envelope grid using all corner projections
            grid_size = config.HIGH_RES_GRID_SIZE 
            global_roi_grid_points_3d, global_grid_bounds = create_simple_envelope_grid(
                plane_projector, 
                all_corners_2d,
                grid_size
            )
            
            
            high_res_images = []
            rectification_info = {
                'painting_name': painting_name,
                'num_images': len(image_files),
                'high_res_images': [],
                'roi_bounds_plane': roi_bounds_plane,
                'global_camera_params': global_camera_params,
                'plane_normal': plane_normal.tolist(),
                'plane_center': plane_center.tolist(),
                'target_resolution': target_resolution,
                'timestamp': datetime.now().isoformat()
            }
            
            for i, image_file in enumerate(image_files):
                print(f"Processing image {i+1}/{len(image_files)}: {image_file.name}")
                
                # Find pose data for this image
                pose_data = None
                for img_id, img_data in images_data.items():
                    if img_data.get('name') == image_file.name:
                        pose_data = img_data.get('pose')
                        break
                
                if not pose_data:
                    print(f"No pose data found for {image_file.name}")
                    continue


                """True orthorectification using global grid (same grid for all images of painting)"""
                # Load the image
                img = cv2.imread(str(image_file))
                if img is None:
                    print(f"Could not load image: {image_file}")
                    return None
                
                print(f"Image loaded: {img.shape}")
                
                # Extract pose information
                if not pose_data:
                    print(f"No pose data available for {image_file.name}")
                    return None
                
                print(f"Pose data: R shape={np.array(pose_data['rotation_matrix']).shape}, t shape={np.array(pose_data['translation']).shape}")
                
                # Perform true orthorectification using global grid
                rectified = rectify_image_true_ortho_global(
                    img, camera_projector, pose_data, global_roi_grid_points_3d, global_grid_bounds['grid_width'], global_grid_bounds['grid_height']
                )
                
                if rectified is not None:
                    
                    # Save high resolution rectified image
                    output_path = self.high_res_dir / f"{painting_name}_{image_file.stem}_high_res.png"
                    cv2.imwrite(str(output_path), rectified)
                    print(f"Saved high res rectified image: {output_path.name}")
                    
                    high_res_images.append(rectified)
                    
                    # Add to rectification info
                    rectification_info['high_res_images'].append({
                        'original_image': image_file.name,
                        'high_res_image': output_path.name,
                        'image_index': i,
                        'resolution': rectified.shape[:2]
                    })
            
            if not high_res_images:
                print(f"[ERROR] No images could be high-res rectified for {painting_name}")
                continue
            
            high_res_results[painting_name] = rectification_info
            
            # Save intermediate results
            self.save_result(f"high_res_rectification_data_{painting_name}", rectification_info)
            
            print(f"[OK] High resolution true orthorectification completed for {painting_name}")
            print(f"  ROI plane bounds: {roi_bounds_plane}")
            print(f"  Target resolution: {target_resolution}x{target_resolution}")
        
        # Save combined results
        step_results = {
            'high_res_results': high_res_results,
            'global_camera_params': global_camera_params,
            'num_paintings': len(high_res_results),
            'timestamp': datetime.now().isoformat()
        }
        
        self.save_result("step7_high_res_rectification_results", step_results)
        
        print(f"[OK] Step 7 completed. High resolution true orthorectification for {len(high_res_results)} paintings.")
        
        return step_results

   
    
    def is_point_inside_polygon(self, point, polygon):
        """
        Check if a point is inside a polygon using ray casting algorithm
        
        Args:
            point: 2D point [x, y]
            polygon: Array of polygon vertices [[x1, y1], [x2, y2], ...]
            
        Returns:
            True if point is inside polygon
        """
        x, y = point
        n = len(polygon)
        inside = False
        
        p1x, p1y = polygon[0]
        for i in range(n + 1):
            p2x, p2y = polygon[i % n]
            if y > min(p1y, p2y):
                if y <= max(p1y, p2y):
                    if x <= max(p1x, p2x):
                        if p1y != p2y:
                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                        if p1x == p2x or x <= xinters:
                            inside = not inside
            p1x, p1y = p2x, p2y
        
        return inside


    def create_strict_rectangular_roi_grid(self, plane_projector, roi_bounds_plane, target_resolution):
        """
        Create grid for exactly the ROI rectangle selected in Step 6 (no margin, no padding).
        """
        u_min = roi_bounds_plane['u_min']
        u_max = roi_bounds_plane['u_max']
        v_min = roi_bounds_plane['v_min']
        v_max = roi_bounds_plane['v_max']

        roi_width = u_max - u_min
        roi_height = v_max - v_min
        aspect_ratio = roi_width / roi_height

        if aspect_ratio > 1:
            grid_width = target_resolution
            grid_height = int(target_resolution / aspect_ratio)
        else:
            grid_height = target_resolution
            grid_width = int(target_resolution * aspect_ratio)

        grid_points_3d = []
        valid_coords = []

        for i in range(grid_height):
            for j in range(grid_width):
                u = u_min + (j / (grid_width - 1)) * roi_width
                v = v_min + (i / (grid_height - 1)) * roi_height
                point_3d = plane_projector.plane_2d_to_world(np.array([u, v]))
                grid_points_3d.append(point_3d)
                valid_coords.append((i, j))

        grid_info = {
            'min_i': 0,
            'max_i': grid_height - 1,
            'min_j': 0,
            'max_j': grid_width - 1,
            'grid_width': grid_width,
            'grid_height': grid_height,
            'total_points': len(grid_points_3d),
            'valid_indices': valid_coords,
            'roi_bounds': roi_bounds_plane,
            'roi_dimensions': {'width': roi_width, 'height': roi_height, 'aspect_ratio': aspect_ratio}
        }

        return np.array(grid_points_3d), grid_info


if __name__ == "__main__":
    # Test the step independently
    step = HighResRectificationStep()
    results = step.run()
    if results:
        print(f"Step 7 completed. High resolution true orthorectification for {results['num_paintings']} paintings.") 