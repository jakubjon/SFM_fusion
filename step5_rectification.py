"""
Step 5: True orthorectification of all individual pictures using proper camera projection
with global calibration and creating overviews for each batch
"""

import cv2
import numpy as np
from pathlib import Path
from datetime import datetime
from step_base import StepBase
import config
import pycolmap
from camera_utils import CameraProjector, PlaneProjector, create_rectification_grid, rectify_image_true_ortho_global, create_overview_fusion


class RectificationStep(StepBase):
    """Step 5: True orthorectification with global calibration"""
    
    def __init__(self, photos_dir=config.PHOTOS_DIR, output_dir=config.OUTPUT_DIR):
        super().__init__(output_dir)
        self.photos_dir = Path(photos_dir)
        self.painting_sets = [d for d in self.photos_dir.iterdir() if d.is_dir()]
        self.rectified_dir = self.output_dir / 'rectified'
        self.rectified_dir.mkdir(exist_ok=True)
    
    def get_input_requirements(self):
        """Return required inputs for this step"""
        return [
            "step3_recalculate_positions_results",
            "step4_point_cloud_results"
        ]
    
    def get_output_files(self):
        """Return output files generated by this step"""
        outputs = []
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            outputs.extend([
                f"rectified/{painting_name}_overview.jpg",
                f"rectified/{painting_name}_rectified_*.jpg",
                f"intermediate/rectification_data_{painting_name}.json"
            ])
        outputs.append("intermediate/step5_rectification_results.json")
        return outputs
    

    
    def create_overview(self, rectified_images, painting_name):
        """Create overview from multiple rectified images using proper fusion"""
        if not rectified_images:
            return None
        
        # Use proper fusion instead of simple averaging
        overview = create_overview_fusion(rectified_images)
        
        # Apply basic enhancement
        if overview is not None:
            overview = cv2.convertScaleAbs(overview, alpha=1.1, beta=5)
        
        return overview
    
    def rectify_image_true_ortho_global(self, image_path, pose_data, camera_projector, plane_projector, grid_points_3d, grid_size, painting_name):
        """True orthorectification using global grid (same grid for all images of painting)"""
        # Load the image
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"Could not load image: {image_path}")
            return None
        
        print(f"Image loaded: {img.shape}")
        
        # Extract pose information
        if not pose_data:
            print(f"No pose data available for {image_path.name}")
            return None
        
        print(f"Pose data: R shape={np.array(pose_data['rotation_matrix']).shape}, t shape={np.array(pose_data['translation']).shape}")
        
        # Perform true orthorectification using global grid
        rectified = rectify_image_true_ortho_global(
            img, camera_projector, pose_data, grid_points_3d, grid_size
        )
        
        # Check if rectified image is mostly black
        if rectified is not None:
            mean_value = np.mean(rectified)
            print(f"Rectified image mean value: {mean_value:.2f}")
            if mean_value < 10:  # Very dark image
                print(f"WARNING: Rectified image is very dark (mean={mean_value:.2f})")
        
        return rectified
    
    def run(self, **kwargs):
        """
        Perform true orthorectification for all paintings.
        
        Returns:
            dict: Results containing rectification data for each painting
        """
        self.log_step("Step 5: True orthorectification with global calibration")
        
        # Load global reconstructions from Step 3
        step3_results = self.load_result("step3_recalculate_positions_results")
        if not step3_results:
            print("[ERROR] Step 3 results not found. Please run Step 3 first.")
            return None
        
        global_reconstructions = step3_results.get('global_reconstructions', {})
        global_camera_params = step3_results.get('global_camera_params')
        
        if not global_reconstructions:
            print("[ERROR] No global reconstructions found in Step 3 results.")
            return None
        
        # Load point cloud data from Step 4
        step4_results = self.load_result("step4_point_cloud_results")
        if not step4_results:
            print("[ERROR] Step 4 results not found. Please run Step 4 first.")
            return None
        
        point_cloud_data = step4_results.get('point_cloud_data', {})
        
        rectification_results = {}
        
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            print(f"\n{'='*80}")
            print(f"True orthorectification for painting {painting_name}")
            print(f"{'='*80}")
            
            # Check if we already have rectification data
            existing_result = self.load_result(f"rectification_data_{painting_name}")
            if existing_result and config.INTERMEDIATE_RESULTS['save_intermediate'] and not self.should_overwrite_existing():
                print(f"Found existing rectification data for {painting_name}")
                rectification_results[painting_name] = existing_result
                continue
            
            # Get reconstruction data
            reconstruction_data = global_reconstructions.get(painting_name)
            if not reconstruction_data:
                print(f"[ERROR] No reconstruction data found for {painting_name}")
                continue
            
            # Get point cloud data for plane information
            point_cloud_info = point_cloud_data.get(painting_name, {})
            plane_data = point_cloud_info.get('plane_data', {})
            
            # Create camera projector with global calibration
            camera_projector = CameraProjector(global_camera_params)
            
            # Create plane projector ONCE for the entire painting
            plane_normal = np.array(plane_data.get('plane_normal', [0, 0, 1]))
            plane_center = np.array(plane_data.get('plane_center', [0, 0, 0]))
            plane_projector = PlaneProjector(plane_normal, plane_center)
            
            # Get image files
            image_files = list(painting_set.glob('*.jpg')) + list(painting_set.glob('*.jpeg')) + list(painting_set.glob('*.png'))
            
            if not image_files:
                print(f"[ERROR] No image files found for {painting_name}")
                continue
            
            # Get camera poses from reconstruction
            images_data = reconstruction_data.get('images', {})
            
            rectified_images = []
            rectification_info = {
                'painting_name': painting_name,
                'num_images': len(image_files),
                'rectified_images': [],
                'global_camera_params': global_camera_params,
                'plane_normal': plane_normal.tolist(),
                'plane_center': plane_center.tolist(),
                'grid_bounds': None,
                'timestamp': datetime.now().isoformat()
            }
            
            # First pass: collect all corner projections to establish consistent bounds
            all_corners_2d = []
            for image_file in image_files:
                # Find pose data for this image
                pose_data = None
                for img_id, img_data in images_data.items():
                    if img_data.get('name') == image_file.name:
                        pose_data = img_data.get('pose')
                        break
                
                if pose_data:
                    # Get image corners in 3D world coordinates by intersecting with painting plane
                    corners_3d = camera_projector.get_image_corners_3d(pose_data, plane_projector)
                    if len(corners_3d) == 4:
                        # Project corners to 2D plane
                        for corner_3d in corners_3d:
                            corner_2d = plane_projector.world_to_plane_2d(corner_3d)
                            all_corners_2d.append(corner_2d)
            
            if not all_corners_2d:
                print(f"[ERROR] No valid corner projections found for {painting_name}")
                continue
            
            # Calculate global bounds from all corners
            all_corners_2d = np.array(all_corners_2d)
            global_min_u, global_min_v = all_corners_2d.min(axis=0)
            global_max_u, global_max_v = all_corners_2d.max(axis=0)
            
            print(f"Global bounds from all images: u=[{global_min_u:.3f}, {global_max_u:.3f}], v=[{global_min_v:.3f}, {global_max_v:.3f}]")
            
            # Load 3D reconstruction points for better bounds
            reconstruction_points_3d = None
            try:
                reconstruction_path = self.output_dir / painting_name / 'global' / '0'
                if reconstruction_path.exists():
                    reconstruction = pycolmap.Reconstruction(str(reconstruction_path))
                    points3D = reconstruction.points3D
                    
                    if len(points3D) > 0:
                        # Extract 3D point coordinates
                        points3D_coords = []
                        for point3D in points3D.values():
                            points3D_coords.append(point3D.xyz)
                        
                        reconstruction_points_3d = points3D_coords
                        print(f"Loaded {len(reconstruction_points_3d)} reconstruction points for better bounds")
                    else:
                        print("No 3D points found in reconstruction")
                else:
                    print(f"Reconstruction not found at {reconstruction_path}")
            except Exception as e:
                print(f"Failed to load reconstruction points: {e}")
            
            # Create global rectification grid using all corners and reconstruction points
            grid_size = config.GRID_SIZE // 2  # Reduced resolution for performance
            global_grid_points_3d, global_grid_bounds = create_rectification_grid(
                plane_projector, 
                [],  # We'll use reconstruction points instead of individual corners
                grid_size, 
                margin=config.RECTIFICATION_CONFIG['envelope_margin'],
                reconstruction_points_3d=reconstruction_points_3d,
                global_bounds=(global_min_u, global_max_u, global_min_v, global_max_v)
            )
            
            print(f"Created global grid: {len(global_grid_points_3d)} points, bounds={global_grid_bounds}")
            
            # Second pass: rectify each image using the global grid
            for i, image_file in enumerate(image_files):
                print(f"Processing image {i+1}/{len(image_files)}: {image_file.name}")
                
                # Find pose data for this image
                pose_data = None
                for img_id, img_data in images_data.items():
                    if img_data.get('name') == image_file.name:
                        pose_data = img_data.get('pose')
                        break
                
                if not pose_data:
                    print(f"No pose data found for {image_file.name}")
                    continue
                
                # True orthorectification using global grid
                result = self.rectify_image_true_ortho_global(
                    image_file, pose_data, camera_projector, plane_projector, 
                    global_grid_points_3d, grid_size, painting_name
                )
                
                if result is not None:
                    rectified = result
                    rectified_images.append(rectified)
                    
                    # Save individual rectified image
                    output_path = self.rectified_dir / f"{painting_name}_{image_file.stem}_rectified.jpg"
                    cv2.imwrite(str(output_path), rectified)
                    print(f"Saved rectified image: {output_path.name}")
                    
                    # Store global grid bounds
                    if rectification_info['grid_bounds'] is None:
                        rectification_info['grid_bounds'] = global_grid_bounds
                    
                    # Add to rectification info
                    rectification_info['rectified_images'].append({
                        'original_image': image_file.name,
                        'rectified_image': output_path.name,
                        'image_index': i
                    })
            
            if not rectified_images:
                print(f"[WARNING] No images could be rectified for {painting_name}, creating placeholder data")
                # Create placeholder rectification data to ensure downstream steps can run
                rectification_info['rectified_images'] = []
                rectification_info['overview_image'] = None
                rectification_info['status'] = 'failed'
                rectification_results[painting_name] = rectification_info
                
                # Save intermediate results even for failed rectification
                if config.INTERMEDIATE_RESULTS['save_rectification_data']:
                    self.save_result(f"rectification_data_{painting_name}", rectification_info)
                
                print(f"[WARNING] Created placeholder rectification data for {painting_name}")
                continue
            
            # Create overview using proper fusion
            overview = self.create_overview(rectified_images, painting_name)
            if overview is not None:
                overview_path = self.rectified_dir / f"{painting_name}_overview.jpg"
                cv2.imwrite(str(overview_path), overview)
                print(f"Overview saved: {overview_path.name}")
                
                rectification_info['overview_image'] = str(overview_path)
            
            rectification_results[painting_name] = rectification_info
            
            # Save intermediate results
            if config.INTERMEDIATE_RESULTS['save_rectification_data']:
                self.save_result(f"rectification_data_{painting_name}", rectification_info)
            
            print(f"[OK] True orthorectification completed for {painting_name}")
        
        # Save combined results
        step_results = {
            'rectification_results': rectification_results,
            'global_camera_params': global_camera_params,
            'num_paintings': len(rectification_results),
            'timestamp': datetime.now().isoformat()
        }
        
        self.save_result("step5_rectification_results", step_results)
        
        successful_rectifications = sum(1 for info in rectification_results.values() if info.get('status') != 'failed')
        print(f"[OK] Step 5 completed. True orthorectification for {len(rectification_results)} paintings ({successful_rectifications} successful).")
        
        return step_results


if __name__ == "__main__":
    # Test the step independently
    step = RectificationStep()
    results = step.run()
    if results:
        print(f"Step 5 completed. True orthorectified images for {results['num_paintings']} paintings.") 