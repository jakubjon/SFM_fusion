"""
Step 5: Image low resolution rectification of all individual pictures of each individual painting batches 
with global calibration and creating overviews for each batch
"""

import cv2
import numpy as np
from pathlib import Path
from datetime import datetime
from step_base import StepBase
import config
import pycolmap


class RectificationStep(StepBase):
    """Step 5: Image rectification with global calibration"""
    
    def __init__(self, photos_dir=config.PHOTOS_DIR, output_dir=config.OUTPUT_DIR):
        super().__init__(output_dir)
        self.photos_dir = Path(photos_dir)
        self.painting_sets = [d for d in self.photos_dir.iterdir() if d.is_dir()]
        self.rectified_dir = self.output_dir / 'rectified'
        self.rectified_dir.mkdir(exist_ok=True)
    
    def get_input_requirements(self):
        """Return required inputs for this step"""
        return [
            "step3_recalculate_positions_results",
            "step4_point_cloud_results"
        ]
    
    def get_output_files(self):
        """Return output files generated by this step"""
        outputs = []
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            outputs.extend([
                f"rectified/{painting_name}_overview.jpg",
                f"rectified/{painting_name}_rectified_*.jpg",
                f"intermediate/rectification_data_{painting_name}.json"
            ])
        outputs.append("intermediate/step5_rectification_results.json")
        return outputs
    
    def qvec2rotmat(self, qvec):
        """Convert quaternion to rotation matrix"""
        w, x, y, z = qvec
        return np.array([
            [1 - 2*y**2 - 2*z**2, 2*x*y - 2*z*w, 2*x*z + 2*y*w],
            [2*x*y + 2*z*w, 1 - 2*x**2 - 2*z**2, 2*y*z - 2*x*w],
            [2*x*z - 2*y*w, 2*y*z + 2*x*w, 1 - 2*x**2 - 2*y**2]
        ])
    
    def rectify_image_to_plane(self, image_path, pose_data, K, plane_normal, plane_center, painting_name):
        """Rectify image to painting plane using proper 2D coordinate system with rectangular envelope"""
        # Load the image
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"Could not load image: {image_path}")
            return None
        
        # Extract pose information
        if not pose_data:
            print(f"No pose data available for {image_path.name}")
            return None
        
        # Create camera projection matrix
        rotation_matrix = np.array(pose_data['rotation_matrix'])
        translation = np.array(pose_data['translation'])
        
        # Create pose matrix
        pose = np.eye(4)
        pose[:3, :3] = rotation_matrix
        pose[:3, 3] = translation
        
        # Create camera projection matrix
        P = K @ pose[:3]  # camera projection matrix

        # Step 1: Create 2D coordinate system on the painting plane
        # Create two vectors perpendicular to the normal
        if abs(plane_normal[0]) < 0.9:
            v1 = np.array([1, 0, 0])
        else:
            v1 = np.array([0, 1, 0])
        v2 = np.cross(plane_normal, v1)
        v1 = np.cross(v2, plane_normal)
        
        # Normalize
        v1 = v1 / np.linalg.norm(v1)
        v2 = v2 / np.linalg.norm(v2)
        
        # Step 2: Load 3D points from COLMAP reconstruction
        reconstruction_path = self.output_dir / painting_name / 'global' / '0'
        if not reconstruction_path.exists():
            print(f"[ERROR] COLMAP reconstruction not found for {painting_name}")
            return None
        
        try:
            # Load the reconstruction
            reconstruction = pycolmap.Reconstruction(str(reconstruction_path))
            points3D = reconstruction.points3D
            
            if len(points3D) < 10:
                print(f"Not enough 3D points for rectification: {image_path.name}")
                return None
            
            # Extract 3D point coordinates
            points3D_coords = []
            for point3D in points3D.values():
                points3D_coords.append(point3D.xyz)
            
            points3D_coords = np.array(points3D_coords)
            
            # Step 3: Project all 3D points to the 2D coordinate system
            points_2d_plane = []
            for point_3d in points3D_coords:
                # Vector from plane center to point
                vec = point_3d - plane_center
                
                # Project to 2D coordinate system
                u = np.dot(vec, v1)
                v = np.dot(vec, v2)
                points_2d_plane.append([u, v])
            
            points_2d_plane = np.array(points_2d_plane)
            
            # Step 4: Find the rectangular envelope
            min_u, min_v = points_2d_plane.min(axis=0)
            max_u, max_v = points_2d_plane.max(axis=0)
            
            # Add margin
            margin = config.RECTIFICATION_CONFIG['envelope_margin']
            u_range = max_u - min_u
            v_range = max_v - min_v
            min_u -= u_range * margin
            max_u += u_range * margin
            min_v -= v_range * margin
            max_v += v_range * margin
            
            # Step 5: Create the rectification grid
            grid_size = config.GRID_SIZE // 2  # Reduced resolution for performance
            rectified_points_3d = []
            
            for i in range(grid_size):
                for j in range(grid_size):
                    # Map grid coordinates to 2D plane coordinates
                    u = min_u + (i / (grid_size - 1)) * (max_u - min_u)
                    v = min_v + (j / (grid_size - 1)) * (max_v - min_v)
                    
                    # Convert back to 3D
                    point_3d = plane_center + u * v1 + v * v2
                    rectified_points_3d.append(point_3d)
            
            rectified_points_3d = np.array(rectified_points_3d)
            
            # Step 6: Project rectified points to image
            src_points = []
            dst_points = []
            
            for i, point_3d in enumerate(rectified_points_3d):
                point_homo = np.append(point_3d, 1)
                point_img = P @ point_homo
                point_img = point_img[:2] / point_img[2]
                
                # Check if point is in image bounds
                if (0 <= point_img[0] < img.shape[1] and 
                    0 <= point_img[1] < img.shape[0]):
                    src_points.append(point_img)
                    # Map to rectified coordinates
                    dst_points.append([i % grid_size, i // grid_size])
            
            if len(src_points) < 4:
                print(f"Not enough valid points for rectification: {image_path.name}")
                return None
            
            src_points = np.array(src_points, dtype=np.float32)
            dst_points = np.array(dst_points, dtype=np.float32)
            
            # Step 7: Compute homography and apply rectification
            H = cv2.findHomography(src_points, dst_points)[0]
            rectified = cv2.warpPerspective(img, H, (grid_size, grid_size))
            
            return rectified
            
        except Exception as e:
            print(f"[ERROR] Failed to load reconstruction for {painting_name}: {e}")
            return None
    
    def create_overview(self, rectified_images, painting_name):
        """Create overview from multiple rectified images"""
        if not rectified_images:
            return None
        
        # Simple averaging for overview creation
        # In a more sophisticated implementation, you would use better fusion methods
        overview = np.mean(rectified_images, axis=0).astype(np.uint8)
        
        # Apply basic enhancement
        overview = cv2.convertScaleAbs(overview, alpha=1.1, beta=5)
        
        return overview
    
    def run(self, **kwargs):
        """
        Perform low resolution rectification for all paintings.
        
        Returns:
            dict: Results containing rectification data for each painting
        """
        self.log_step("Step 5: Low resolution rectification with global calibration")
        
        # Load global reconstructions from Step 3
        step3_results = self.load_result("step3_recalculate_positions_results")
        if not step3_results:
            print("[ERROR] Step 3 results not found. Please run Step 3 first.")
            return None
        
        global_reconstructions = step3_results.get('global_reconstructions', {})
        global_camera_params = step3_results.get('global_camera_params')
        
        if not global_reconstructions:
            print("[ERROR] No global reconstructions found in Step 3 results.")
            return None
        
        # Load point cloud data from Step 4
        step4_results = self.load_result("step4_point_cloud_results")
        if not step4_results:
            print("[ERROR] Step 4 results not found. Please run Step 4 first.")
            return None
        
        point_cloud_data = step4_results.get('point_cloud_data', {})
        
        rectification_results = {}
        
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            print(f"\n{'='*80}")
            print(f"Rectifying images for painting {painting_name}")
            print(f"{'='*80}")
            
            # Check if we already have rectification data
            existing_result = self.load_result(f"rectification_data_{painting_name}")
            if existing_result and config.INTERMEDIATE_RESULTS['save_intermediate'] and not self.should_overwrite_existing():
                print(f"Found existing rectification data for {painting_name}")
                rectification_results[painting_name] = existing_result
                continue
            
            # Get reconstruction data
            reconstruction_data = global_reconstructions.get(painting_name)
            if not reconstruction_data:
                print(f"[ERROR] No reconstruction data found for {painting_name}")
                continue
            
            # Get point cloud data for plane information
            point_cloud_info = point_cloud_data.get(painting_name, {})
            plane_data = point_cloud_info.get('plane_data', {})
            
            # Extract camera intrinsics from global calibration
            if isinstance(global_camera_params, dict):
                params = global_camera_params['params']
                if len(params) >= 4:  # SIMPLE_RADIAL has 4 parameters
                    fx, cx, cy, k1 = params[:4]
                    K = np.array([[fx, 0, cx], [0, fx, cy], [0, 0, 1]])
                    print(f"Using global calibration: focal_length={fx:.2f}, k1={k1:.6f}")
                else:
                    print(f"Invalid global camera parameters for {painting_name}")
                    continue
            else:
                print(f"Invalid global camera parameters format for {painting_name}")
                continue
            
            # Get plane information (use placeholder if not available)
            plane_normal = np.array(plane_data.get('plane_normal', [0, 0, 1]))
            plane_center = np.array(plane_data.get('plane_center', [0, 0, 0]))
            
            # Get image files
            image_files = list(painting_set.glob('*.jpg')) + list(painting_set.glob('*.jpeg')) + list(painting_set.glob('*.png'))
            
            if not image_files:
                print(f"[ERROR] No image files found for {painting_name}")
                continue
            
            # Get camera poses from reconstruction
            images_data = reconstruction_data.get('images', {})
            
            rectified_images = []
            rectification_info = {
                'painting_name': painting_name,
                'num_images': len(image_files),
                'rectified_images': [],
                'global_camera_params': global_camera_params,
                'plane_normal': plane_normal.tolist(),
                'plane_center': plane_center.tolist(),
                'timestamp': datetime.now().isoformat()
            }
            
            for i, image_file in enumerate(image_files):
                print(f"Processing image {i+1}/{len(image_files)}: {image_file.name}")
                
                # Find pose data for this image
                pose_data = None
                for img_id, img_data in images_data.items():
                    if img_data.get('name') == image_file.name:
                        pose_data = img_data.get('pose')
                        break
                
                if not pose_data:
                    print(f"No pose data found for {image_file.name}")
                    continue
                
                # Rectify image
                rectified = self.rectify_image_to_plane(
                    image_file, pose_data, K, plane_normal, plane_center, painting_name
                )
                
                if rectified is not None:
                    rectified_images.append(rectified)
                    
                    # Save individual rectified image
                    output_path = self.rectified_dir / f"{painting_name}_{image_file.stem}_rectified.jpg"
                    cv2.imwrite(str(output_path), rectified)
                    print(f"Saved rectified image: {output_path.name}")
                    
                    # Add to rectification info
                    rectification_info['rectified_images'].append({
                        'original_image': image_file.name,
                        'rectified_image': output_path.name,
                        'image_index': i
                    })
            
            if not rectified_images:
                print(f"[WARNING] No images could be rectified for {painting_name}, creating placeholder data")
                # Create placeholder rectification data to ensure downstream steps can run
                rectification_info['rectified_images'] = []
                rectification_info['overview_image'] = None
                rectification_info['status'] = 'failed'
                rectification_results[painting_name] = rectification_info
                
                # Save intermediate results even for failed rectification
                if config.INTERMEDIATE_RESULTS['save_rectification_data']:
                    self.save_result(f"rectification_data_{painting_name}", rectification_info)
                
                print(f"[WARNING] Created placeholder rectification data for {painting_name}")
                continue
            
            # Create overview
            overview = self.create_overview(rectified_images, painting_name)
            if overview is not None:
                overview_path = self.rectified_dir / f"{painting_name}_overview.jpg"
                cv2.imwrite(str(overview_path), overview)
                print(f"Overview saved: {overview_path.name}")
                
                rectification_info['overview_image'] = str(overview_path)
            
            rectification_results[painting_name] = rectification_info
            
            # Save intermediate results
            if config.INTERMEDIATE_RESULTS['save_rectification_data']:
                self.save_result(f"rectification_data_{painting_name}", rectification_info)
            
            print(f"[OK] Rectification completed for {painting_name}")
        
        # Save combined results
        step_results = {
            'rectification_results': rectification_results,
            'global_camera_params': global_camera_params,
            'num_paintings': len(rectification_results),
            'timestamp': datetime.now().isoformat()
        }
        
        self.save_result("step5_rectification_results", step_results)
        
        successful_rectifications = sum(1 for info in rectification_results.values() if info.get('status') != 'failed')
        print(f"[OK] Step 5 completed. Rectification data for {len(rectification_results)} paintings ({successful_rectifications} successful).")
        
        return step_results


if __name__ == "__main__":
    # Test the step independently
    step = RectificationStep()
    results = step.run()
    if results:
        print(f"Step 5 completed. Rectified images for {results['num_paintings']} paintings.") 