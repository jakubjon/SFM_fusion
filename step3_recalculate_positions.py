"""
Step 3: Recalculate camera positions of each individual painting batch with global calibration
"""

import pycolmap
import numpy as np
from pathlib import Path
from datetime import datetime
from step_base import StepBase
import config


class RecalculatePositionsStep(StepBase):
    """Step 3: Recalculate camera positions with global calibration"""
    
    def __init__(self, photos_dir=config.PHOTOS_DIR, output_dir=config.OUTPUT_DIR):
        super().__init__(output_dir)
        self.photos_dir = Path(photos_dir)
        self.painting_sets = [d for d in self.photos_dir.iterdir() if d.is_dir()]
    
    def get_input_requirements(self):
        """Return required inputs for this step"""
        return [
            "step1_local_sfm_results",
            "step2_global_calibration_results"
        ]
    
    def get_output_files(self):
        """Return output files generated by this step"""
        outputs = []
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            outputs.extend([
                f"intermediate/global_reconstruction_{painting_name}.json",
                f"intermediate/global_camera_poses_{painting_name}.json"
            ])
        outputs.append("intermediate/step3_recalculate_positions_results.json")
        return outputs
    
    def run_colmap_with_global_calibration(self, image_dir, output_path, database_path, painting_name, global_camera_params):
        """Run COLMAP SfM with global camera calibration using existing features from Step 1"""
        self.log_step("COLMAP with global calibration", painting_name)
        
        try:
            # Ensure output directory exists
            output_path = Path(output_path)
            output_path.mkdir(parents=True, exist_ok=True)
            
            # Copy database from Step 1 instead of recreating it
            step1_database_path = self.output_dir / painting_name / 'database.db'
            if not step1_database_path.exists():
                print(f"[ERROR] Step 1 database not found: {step1_database_path}")
                return None
            
            # Copy the database from Step 1
            import shutil
            shutil.copy2(step1_database_path, database_path)
            print(f"Copied database from Step 1: {database_path}")
            
            # Load the database and update camera parameters
            self.log_step("Updating camera parameters", painting_name)
            database = pycolmap.Database(str(database_path))
            camera_id = 1  # Assuming single camera for all images
            
            # Convert global parameters to pycolmap format
            params = global_camera_params['params']
            if global_camera_params['model'] == 'SIMPLE_RADIAL':
                # SIMPLE_RADIAL: fx, cx, cy, k1
                camera_params = [params[0], params[1], params[2], params[3]]
            else:
                # Fallback to SIMPLE_PINHOLE: fx, cx, cy
                camera_params = params[:3]
            
            # Create Camera object and update database
            from pycolmap import Camera
            camera = Camera(
                camera_id=camera_id,
                model=global_camera_params['model'],
                width=global_camera_params['width'],
                height=global_camera_params['height'],
                params=camera_params
            )
            database.update_camera(camera)
            print(f"Camera updated with global calibration: focal_length={params[0]:.2f}")
            
            # Run incremental mapping with fixed camera parameters (features and matches already exist)
            self.log_step("Camera position recalculation", painting_name)
            reconstructions = pycolmap.incremental_mapping(
                database_path=str(database_path),
                image_path=str(image_dir),
                output_path=str(output_path)
            )
            print(f"Reconstruction with global calibration completed")
            
            # Return the first (and usually only) reconstruction
            if reconstructions:
                recon = list(reconstructions.values())[0]
                
                # Calculate reprojection error
                if hasattr(recon, 'points3D') and recon.points3D:
                    total_error = 0
                    total_points = 0
                    for point3D in recon.points3D.values():
                        if hasattr(point3D, 'error'):
                            total_error += point3D.error
                            total_points += 1
                    
                    if total_points > 0:
                        avg_error = total_error / total_points
                        print(f"Average reprojection error with global calibration: {avg_error:.4f} pixels")
                
                return recon
            return None
        except Exception as e:
            print(f"COLMAP with global calibration failed for {image_dir}: {e}")
            return None
    
    def extract_pose_from_image(self, img_obj):
        """Extract pose data from pycolmap Image object in serializable format"""
        try:
            # Get the camera pose
            rigid = img_obj.cam_from_world()
            
            # Extract rotation matrix and translation
            rotation_matrix = np.array(rigid.rotation.matrix())
            translation = np.array(rigid.translation)
            
            # Convert to serializable format
            return {
                'rotation_matrix': rotation_matrix.tolist(),
                'translation': translation.tolist(),
                'camera_center': (-rotation_matrix.T @ translation).tolist()
            }
        except Exception as e:
            print(f"Error extracting pose from image {img_obj.name}: {e}")
            return None
    
    def run(self, **kwargs):
        """
        Recalculate camera positions using global calibration.
        
        Returns:
            dict: Results containing recalculated camera positions
        """
        self.log_step("Step 3: Recalculate camera positions with global calibration")
        
        # Load global calibration from Step 2
        step2_results = self.load_result("step2_global_calibration_results")
        if not step2_results:
            print("[ERROR] Step 2 results not found. Please run Step 2 first.")
            return None
        
        global_camera_params = step2_results.get('global_camera_params')
        if not global_camera_params:
            print("[ERROR] Global camera parameters not found in Step 2 results.")
            return None
        
        # Load local reconstructions from Step 1
        step1_results = self.load_result("step1_local_sfm_results")
        if not step1_results:
            print("[ERROR] Step 1 results not found. Please run Step 1 first.")
            return None
        
        local_reconstructions = step1_results.get('local_reconstructions', {})
        
        global_reconstructions = {}
        global_camera_poses = {}
        
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            print(f"\n{'='*80}")
            print(f"Recalculating positions for painting {painting_name}")
            print(f"{'='*80}")
            
            # Check if we already have global reconstruction
            existing_result = self.load_result(f"global_reconstruction_{painting_name}")
            if existing_result and config.INTERMEDIATE_RESULTS['save_intermediate'] and not self.should_overwrite_existing():
                print(f"Found existing global reconstruction for {painting_name}")
                global_reconstructions[painting_name] = existing_result
                continue
            
            # Ensure output directory exists
            output_dir = self.output_dir / painting_name / 'global'
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Run COLMAP with global calibration
            recon = self.run_colmap_with_global_calibration(
                painting_set, 
                output_dir,
                output_dir / 'database.db',
                painting_name,
                global_camera_params
            )
            
            if not recon:
                print(f"[ERROR] Global reconstruction failed for {painting_name}")
                continue
            
            # Extract camera poses
            camera_poses = {}
            for img_id, img_obj in recon.images.items():
                pose_data = self.extract_pose_from_image(img_obj)
                if pose_data:
                    camera_poses[img_obj.name] = pose_data
            
            # Save reconstruction summary
            reconstruction_summary = {
                'cameras': {k: self.to_serializable(v) for k, v in recon.cameras.items()},
                'images': {k: {
                    'name': v.name,
                    'pose': self.to_serializable(self.extract_pose_from_image(v))
                } for k, v in recon.images.items()},
                'num_points3D': len(recon.points3D),
                'painting_name': painting_name,
                'global_camera_params': global_camera_params,
                'timestamp': datetime.now().isoformat()
            }
            
            global_reconstructions[painting_name] = reconstruction_summary
            global_camera_poses[painting_name] = camera_poses
            
            # Save intermediate results
            self.save_result(f"global_reconstruction_{painting_name}", reconstruction_summary)
            self.save_result(f"global_camera_poses_{painting_name}", camera_poses)
            
            print(f"[OK] Global reconstruction completed for {painting_name}")
        
        # Save combined results
        step_results = {
            'global_reconstructions': global_reconstructions,
            'global_camera_poses': global_camera_poses,
            'global_camera_params': global_camera_params,
            'num_paintings': len(global_reconstructions),
            'timestamp': datetime.now().isoformat()
        }
        
        self.save_result("step3_recalculate_positions_results", step_results)
        
        print(f"[OK] Step 3 completed. Recalculated positions for {len(global_reconstructions)} paintings.")
        
        return step_results


if __name__ == "__main__":
    # Test the step independently
    step = RecalculatePositionsStep()
    results = step.run()
    if results:
        print(f"Step 3 completed. Recalculated positions for {results['num_paintings']} paintings.") 