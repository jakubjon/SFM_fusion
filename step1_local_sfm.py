"""
Step 1: Run local SfM for initial camera positions and using initial camera calibration
"""

import pycolmap
import cv2
import numpy as np
from pathlib import Path
from datetime import datetime
from step_base import StepBase
import config


class LocalSfMStep(StepBase):
    """Step 1: Run local SfM for initial camera positions"""
    
    def __init__(self, photos_dir=config.PHOTOS_DIR, output_dir=config.OUTPUT_DIR):
        super().__init__(output_dir)
        self.photos_dir = Path(photos_dir)
        self.painting_sets = [d for d in self.photos_dir.iterdir() if d.is_dir()]
        print(f"Found {len(self.painting_sets)} painting sets: {[p.name for p in self.painting_sets]}")
        
        # Store local camera calibrations for comparison
        self.local_camera_calibrations = {}
    
    def get_input_requirements(self):
        """Return required inputs for this step"""
        return ["Photos directory with painting subdirectories"]
    
    def get_output_files(self):
        """Return output files generated by this step"""
        outputs = []
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            outputs.extend([
                f"intermediate/local_reconstruction_{painting_name}.json",
                f"intermediate/local_calibration_{painting_name}.json"
            ])
        return outputs
    
    def extract_exif_calibration(self, image_path):
        """Extract preliminary camera calibration from EXIF data"""
        try:
            import exifread
            with open(image_path, 'rb') as f:
                tags = exifread.process_file(f)
            
            # Extract focal length and sensor info
            focal_length = None
            if 'EXIF FocalLength' in tags:
                focal_length = float(tags['EXIF FocalLength'].values[0])
            
            # Get image dimensions
            img = cv2.imread(str(image_path))
            if img is not None:
                height, width = img.shape[:2]
                
                # Estimate principal point (center of image)
                cx, cy = width / 2, height / 2
                
                if focal_length:
                    return {
                        'width': width,
                        'height': height,
                        'params': [focal_length, cx, cy, 0, 0],  # fx, cx, cy, k1, k2
                        'model': 'SIMPLE_PINHOLE'
                    }
                else:
                    return {
                        'width': width,
                        'height': height,
                        'params': [max(width, height), cx, cy, 0, 0],  # Default focal length
                        'model': 'SIMPLE_PINHOLE'
                    }
        except ImportError:
            print("exifread not available, using default calibration")
        except Exception as e:
            print(f"Error extracting EXIF: {e}")
        
        return None
    
    def run_colmap_sfm(self, image_dir, output_path, database_path, painting_name):
        """Run COLMAP SfM on a set of images with detailed logging"""
        self.log_step("Registration", painting_name)
        
        try:
            # Ensure output directory exists
            output_path = Path(output_path)
            output_path.mkdir(parents=True, exist_ok=True)
            
            # Create database
            self.log_step("Creating database", painting_name)
            database = pycolmap.Database(str(database_path))
            print(f"Database created: {database_path}")
            
            # Import images to database
            self.log_step("Importing images", painting_name)
            pycolmap.import_images(str(database_path), str(image_dir))
            print(f"Images imported to database")
            
            # Extract features
            self.log_step("Feature extraction", painting_name)
            pycolmap.extract_features(str(database_path), str(image_dir))
            print(f"Features extracted")
            
            # Match features
            self.log_step("Feature matching", painting_name)
            pycolmap.match_exhaustive(str(database_path))
            print(f"Features matched")
            
            # Run incremental mapping
            self.log_step("Preliminary camera position determination", painting_name)
            reconstructions = pycolmap.incremental_mapping(
                database_path=str(database_path),
                image_path=str(image_dir),
                output_path=str(output_path)
            )
            print(f"Initial reconstruction completed")
            
            # Return the first (and usually only) reconstruction
            if reconstructions:
                recon = list(reconstructions.values())[0]
                
                # Calculate reprojection error
                if hasattr(recon, 'points3D') and recon.points3D:
                    total_error = 0
                    total_points = 0
                    for point3D in recon.points3D.values():
                        if hasattr(point3D, 'error'):
                            total_error += point3D.error
                            total_points += 1
                    
                    if total_points > 0:
                        avg_error = total_error / total_points
                        print(f"Average reprojection error: {avg_error:.4f} pixels")
                
                return recon
            return None
        except Exception as e:
            print(f"COLMAP failed for {image_dir}: {e}")
            return None
    
    def extract_pose_from_image(self, img_obj):
        """Extract pose data from pycolmap Image object in serializable format"""
        try:
            # Get the camera pose
            rigid = img_obj.cam_from_world()
            
            # Extract rotation matrix and translation
            rotation_matrix = np.array(rigid.rotation.matrix())
            translation = np.array(rigid.translation)
            
            # Convert to serializable format
            return {
                'rotation_matrix': rotation_matrix.tolist(),
                'translation': translation.tolist(),
                'camera_center': (-rotation_matrix.T @ translation).tolist()
            }
        except Exception as e:
            print(f"Error extracting pose from image {img_obj.name}: {e}")
            return None
    
    def run(self, **kwargs):
        """
        Run local SfM for all painting sets.
        
        Returns:
            dict: Results containing local reconstructions and calibrations
        """
        self.log_step("Step 1: Local SfM for initial camera positions")
        
        local_reconstructions = {}
        local_calibrations = {}
        
        for painting_set in self.painting_sets:
            painting_name = painting_set.name
            print(f"\n{'='*80}")
            print(f"Processing painting {painting_name}")
            print(f"{'='*80}")
            
            # Check if we already have local reconstruction and calibration
            existing_result = self.load_result(f"local_reconstruction_{painting_name}")
            existing_calibration = self.load_result(f"local_calibration_{painting_name}")
            if existing_result and existing_calibration and config.INTERMEDIATE_RESULTS['save_intermediate']:
                print(f"Found existing local reconstruction for {painting_name}")
                local_reconstructions[painting_name] = existing_result
                local_calibrations[painting_name] = existing_calibration
                continue
            
            # Ensure output directory exists
            output_dir = self.output_dir / painting_name
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Run COLMAP SfM
            recon = self.run_colmap_sfm(
                painting_set, 
                output_dir,
                output_dir / 'database.db',
                painting_name
            )
            
            if not recon:
                print(f"[ERROR] COLMAP reconstruction failed for {painting_name}")
                continue
            
            # Store local camera calibration
            if recon.cameras:
                ref_camera_id = list(recon.cameras.keys())[0]
                camera = recon.cameras[ref_camera_id]
                
                # Convert to pinhole model for local calibration
                local_params = camera.params.tolist() if hasattr(camera.params, 'tolist') else list(camera.params)
                if len(local_params) > 3:
                    # Keep only first 3 parameters for pinhole model
                    local_params = local_params[:3]
                
                local_calibration = {
                    'width': camera.width,
                    'height': camera.height,
                    'params': local_params,
                    'model': 'SIMPLE_PINHOLE'  # Use pinhole for local calibrations
                }
                
                local_calibrations[painting_name] = local_calibration
                self.local_camera_calibrations[painting_name] = local_calibration
                print(f"Local camera calibration stored for {painting_name} (pinhole model)")
            
            # Save reconstruction summary
            reconstruction_summary = {
                'cameras': {k: self.to_serializable(v) for k, v in recon.cameras.items()},
                'images': {k: {
                    'name': v.name,
                    'pose': self.to_serializable(self.extract_pose_from_image(v))
                } for k, v in recon.images.items()},
                'num_points3D': len(recon.points3D),
                'painting_name': painting_name,
                'timestamp': datetime.now().isoformat()
            }
            
            local_reconstructions[painting_name] = reconstruction_summary
            
            # Save intermediate results
            if config.INTERMEDIATE_RESULTS['save_local_reconstructions']:
                self.save_result(f"local_reconstruction_{painting_name}", reconstruction_summary)
                self.save_result(f"local_calibration_{painting_name}", local_calibration)
            
            print(f"[OK] Local SfM completed for {painting_name}")
        
        # Save combined results
        combined_results = {
            'local_reconstructions': local_reconstructions,
            'local_calibrations': local_calibrations,
            'num_paintings': len(local_reconstructions),
            'timestamp': datetime.now().isoformat()
        }
        
        self.save_result("step1_local_sfm_results", combined_results)
        
        return combined_results


if __name__ == "__main__":
    # Test the step independently
    step = LocalSfMStep()
    results = step.run()
    print(f"Step 1 completed. Processed {results['num_paintings']} paintings.") 