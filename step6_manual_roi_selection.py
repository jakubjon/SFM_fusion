"""
Step 6: Manual ROI selection with proper coordinate system conversion
"""

import cv2
from pathlib import Path
from datetime import datetime
from step_base import StepBase
import config


class ManualROISelectionStep(StepBase):
    """Step 6: Manual ROI selection with proper coordinate conversion"""
    
    def __init__(self, photos_dir=config.PHOTOS_DIR, output_dir=config.OUTPUT_DIR):
        super().__init__(output_dir)
        self.photos_dir = Path(photos_dir)
        self.painting_sets = [d for d in self.photos_dir.iterdir() if d.is_dir()]
        self.rectified_dir = self.output_dir / 'rectified'
        self.roi_dir = self.output_dir / 'roi_selections'
        self.roi_dir.mkdir(exist_ok=True)
        
        # Mouse callback variables
        self.drawing = False
        self.start_point = None
        self.end_point = None
        self.roi_points = []
    
    def get_input_requirements(self):
        """Return required inputs for this step"""
        return [
            "step5_rectification_results"
        ]
    
    def get_output_files(self):
        """Return output files generated by this step"""
        outputs = []
        # We'll determine the painting names from the input
        outputs.extend([
            "intermediate/roi_selections_*.json",
            "intermediate/step6_roi_selection_results.json"
        ])
        return outputs
    
    def mouse_callback(self, event, x, y, flags, param):
        """Mouse callback for ROI selection"""
        if event == cv2.EVENT_LBUTTONDOWN:
            self.drawing = True
            self.start_point = (x, y)
            self.roi_points = [(x, y)]
        elif event == cv2.EVENT_MOUSEMOVE:
            if self.drawing:
                self.end_point = (x, y)
        elif event == cv2.EVENT_LBUTTONUP:
            self.drawing = False
            self.end_point = (x, y)
            self.roi_points.append((x, y))
    
    def select_roi_interactive(self, image_path, painting_name):
        """Interactive ROI selection for a painting overview"""
        # Load the overview image
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"Could not load overview image: {image_path}")
            return None
        
        # Create window and set mouse callback
        window_name = f"ROI Selection - {painting_name}"
        cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)
        cv2.setMouseCallback(window_name, self.mouse_callback)
        
        # Reset variables
        self.drawing = False
        self.start_point = None
        self.end_point = None
        self.roi_points = []
        
        print(f"\nROI Selection for {painting_name}")
        print("Instructions:")
        print("1. Click and drag to select a rectangular ROI")
        print("2. Press 'r' to reset selection")
        print("3. Press 's' to save selection")
        print("4. Press 'q' to quit without saving")
        print("5. Press 'ESC' to skip this painting")
        
        while True:
            # Create a copy of the image for drawing
            display_img = img.copy()
            
            # Draw current selection
            if self.start_point and self.end_point:
                cv2.rectangle(display_img, self.start_point, self.end_point, (0, 255, 0), 2)
            
            # Draw saved ROI points
            for i, point in enumerate(self.roi_points):
                cv2.circle(display_img, point, 3, (255, 0, 0), -1)
                if i > 0:
                    cv2.line(display_img, self.roi_points[i-1], point, (255, 0, 0), 2)
            
            cv2.imshow(window_name, display_img)
            key = cv2.waitKey(1) & 0xFF
            
            if key == ord('r'):  # Reset
                self.start_point = None
                self.end_point = None
                self.roi_points = []
                print("Selection reset")
            elif key == ord('s'):  # Save
                if len(self.roi_points) >= 2:
                    cv2.destroyWindow(window_name)
                    return self.roi_points
                else:
                    print("Please select at least 2 points for ROI")
            elif key == ord('q'):  # Quit
                cv2.destroyWindow(window_name)
                return None
            elif key == 27:  # ESC
                cv2.destroyWindow(window_name)
                return None
    
    def select_roi_manual(self, image_path, painting_name):
        """Manual ROI selection by clicking on 4 corners of the ROI rectangle"""
        # Load the overview image
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"Could not load overview image: {image_path}")
            return None
        
        # Create window and set mouse callback
        window_name = f"Manual ROI Selection - {painting_name}"
        cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)
        cv2.setMouseCallback(window_name, self.mouse_callback_manual)
        
        # Reset variables for manual selection
        self.manual_roi_points = []
        self.current_point = 0
        self.corner_names = ["Top-Left", "Top-Right", "Bottom-Right", "Bottom-Left"]
        
        print(f"\nManual ROI Selection for {painting_name}")
        print("Instructions:")
        print("1. Click on the 4 corners of the ROI rectangle in this order:")
        print("   - Top-Left corner")
        print("   - Top-Right corner") 
        print("   - Bottom-Right corner")
        print("   - Bottom-Left corner")
        print("2. Press 'r' to reset selection")
        print("3. Press 'q' to quit without saving")
        print("4. Press 'ESC' to skip this painting")
        print(f"\nPlease click on the {self.corner_names[self.current_point]} corner...")
        
        while True:
            # Create a copy of the image for drawing
            display_img = img.copy()
            
            # Draw existing points
            for i, point in enumerate(self.manual_roi_points):
                cv2.circle(display_img, point, 5, (0, 255, 0), -1)
                cv2.putText(display_img, f"{i+1}", (point[0]+10, point[1]-10), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
                if i > 0:
                    cv2.line(display_img, self.manual_roi_points[i-1], point, (0, 255, 0), 2)
            
            # Draw connection from last point to first point to close the rectangle
            if len(self.manual_roi_points) == 3:
                cv2.line(display_img, self.manual_roi_points[2], self.manual_roi_points[0], (0, 255, 0), 2)
            
            # Show current corner to click
            if self.current_point < 4:
                cv2.putText(display_img, f"Click: {self.corner_names[self.current_point]}", 
                           (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
            
            cv2.imshow(window_name, display_img)
            key = cv2.waitKey(1) & 0xFF
            
            if key == ord('r'):  # Reset
                self.manual_roi_points = []
                self.current_point = 0
                print("Selection reset")
                print(f"Please click on the {self.corner_names[self.current_point]} corner...")
            elif key == ord('q') or key == 27:  # Quit or ESC
                cv2.destroyWindow(window_name)
                return None
            
            # Check if we have all 4 points
            if len(self.manual_roi_points) == 4:
                print("All 4 corners selected! Press 's' to save or 'r' to reset.")
                if key == ord('s'):  # Save
                    cv2.destroyWindow(window_name)
                    return self.manual_roi_points
    
    def mouse_callback_manual(self, event, x, y, flags, param):
        """Mouse callback for manual ROI corner selection"""
        if event == cv2.EVENT_LBUTTONDOWN:
            if self.current_point < 4:
                self.manual_roi_points.append((x, y))
                print(f"Selected {self.corner_names[self.current_point]} corner at ({x}, {y})")
                self.current_point += 1
                
                if self.current_point < 4:
                    print(f"Please click on the {self.corner_names[self.current_point]} corner...")
                else:
                    print("All 4 corners selected! Press 's' to save or 'r' to reset.")
    
    def convert_roi_to_plane_coordinates(self, roi_points, grid_bounds, overview_size):
        """
        Convert ROI points from overview image coordinates to painting plane coordinates
        
        Args:
            roi_points: List of [x, y] points in overview image coordinates
            grid_bounds: Grid bounds from Step 5 rectification
            overview_size: [width, height] of overview image
            
        Returns:
            List of [u, v] points in painting plane coordinates
        """
        if not grid_bounds:
            print("[ERROR] No grid bounds available for coordinate conversion")
            return None
        
        # Extract grid bounds
        min_u = grid_bounds['min_u']
        max_u = grid_bounds['max_u']
        min_v = grid_bounds['min_v']
        max_v = grid_bounds['max_v']
        
        # Overview image size
        overview_width, overview_height = overview_size
        
        print(f"Converting ROI coordinates:")
        print(f"  Overview size: {overview_width}x{overview_height}")
        print(f"  Grid bounds: u=[{min_u:.3f}, {max_u:.3f}], v=[{min_v:.3f}, {max_v:.3f}]")
        
        # Convert each ROI point
        plane_roi_points = []
        for i, point in enumerate(roi_points):
            x, y = point
            
            # Map from overview image coordinates to normalized coordinates (0-1)
            norm_x = x / overview_width
            norm_y = y / overview_height
            
            # Map from normalized coordinates to plane coordinates
            u = min_u + norm_x * (max_u - min_u)
            v = min_v + norm_y * (max_v - min_v)
            
            plane_roi_points.append([u, v])
            
            print(f"  Point {i}: overview({x},{y}) -> plane({u:.3f},{v:.3f})")
        
        return plane_roi_points
    
    def save_roi_visualization(self, image_path, roi_points, painting_name):
        """Save ROI visualization image"""
        img = cv2.imread(str(image_path))
        if img is None:
            return
        
        # Draw ROI on image
        if len(roi_points) >= 2:
            # Draw points
            for i, point in enumerate(roi_points):
                cv2.circle(img, point, 5, (0, 255, 0), -1)
                if i > 0:
                    cv2.line(img, roi_points[i-1], point, (0, 255, 0), 2)
            
            # Close the polygon
            if len(roi_points) > 2:
                cv2.line(img, roi_points[-1], roi_points[0], (0, 255, 0), 2)
        
        # Save visualization
        vis_path = self.roi_dir / f"{painting_name}_roi_visualization.jpg"
        cv2.imwrite(str(vis_path), img)
        print(f"ROI visualization saved: {vis_path.name}")
    
    def run(self, **kwargs):
        """
        Allow manual ROI selection with proper coordinate conversion.
        
        Returns:
            dict: Results containing ROI selections for each painting
        """
        self.log_step("Step 6: Manual ROI selection with coordinate conversion")
        
        # Load rectification results from Step 5
        step5_results = self.load_result("step5_rectification_results")
        if not step5_results:
            print("[ERROR] Step 5 results not found. Please run Step 5 first.")
            return None
        
        rectification_results = step5_results.get('rectification_results', {})
        
        if not rectification_results:
            print("[ERROR] No rectification results found in Step 5 results.")
            return None
        
        roi_selections = {}
        
        for painting_name, rectification_data in rectification_results.items():
            print(f"\n{'='*80}")
            print(f"ROI Selection for painting {painting_name}")
            print(f"{'='*80}")
            
            
            # Get overview image path
            overview_image = rectification_data.get('overview_image')
            if not overview_image:
                print(f"[WARNING] No overview image found for {painting_name}, creating placeholder ROI")
                # Create placeholder ROI data for failed rectification
                roi_data = {
                    'painting_name': painting_name,
                    'overview_image': None,
                    'roi_points_overview': [[0, 0], [100, 0], [100, 100], [0, 100]],  # Default 100x100 ROI
                    'roi_points_plane': [[0, 0], [1, 0], [1, 1], [0, 1]],  # Default plane coordinates
                    'roi_bounds_overview': {'x_min': 0, 'x_max': 100, 'y_min': 0, 'y_max': 100},
                    'roi_bounds_plane': {'u_min': 0, 'u_max': 1, 'v_min': 0, 'v_max': 1},
                    'status': 'placeholder',
                    'timestamp': datetime.now().isoformat()
                }
                roi_selections[painting_name] = roi_data
                self.save_result(f"roi_selections_{painting_name}", roi_data)
                print(f"[WARNING] Created placeholder ROI for {painting_name}")
                continue
            
            overview_path = Path(overview_image)
            if not overview_path.exists():
                print(f"[WARNING] Overview image not found: {overview_path}, creating placeholder ROI")
                # Create placeholder ROI data for missing overview
                roi_data = {
                    'painting_name': painting_name,
                    'overview_image': str(overview_path),
                    'roi_points_overview': [[0, 0], [100, 0], [100, 100], [0, 100]],  # Default 100x100 ROI
                    'roi_points_plane': [[0, 0], [1, 0], [1, 1], [0, 1]],  # Default plane coordinates
                    'roi_bounds_overview': {'x_min': 0, 'x_max': 100, 'y_min': 0, 'y_max': 100},
                    'roi_bounds_plane': {'u_min': 0, 'u_max': 1, 'v_min': 0, 'v_max': 1},
                    'status': 'placeholder',
                    'timestamp': datetime.now().isoformat()
                }
                roi_selections[painting_name] = roi_data
                self.save_result(f"roi_selections_{painting_name}", roi_data)
                print(f"[WARNING] Created placeholder ROI for {painting_name}")
                continue
            
            # Use manual ROI selection for user-defined rectification
            roi_points_overview = self.select_roi_manual(overview_path, painting_name)
            
            if roi_points_overview is None:
                print(f"[ERROR] Failed to select ROI for {painting_name}")
                continue
            
            # Get overview image size
            overview_img = cv2.imread(str(overview_path))
            overview_size = (overview_img.shape[1], overview_img.shape[0])  # width, height
            
            # Get grid bounds from rectification data
            grid_bounds = rectification_data.get('grid_bounds')
            
            # Convert ROI to painting plane coordinates
            roi_points_plane = self.convert_roi_to_plane_coordinates(
                roi_points_overview, grid_bounds, overview_size
            )
            
            if roi_points_plane is None:
                print(f"[ERROR] Failed to convert ROI coordinates for {painting_name}")
                continue
            
            # Calculate bounds in both coordinate systems
            roi_bounds_overview = {
                'x_min': min(p[0] for p in roi_points_overview),
                'x_max': max(p[0] for p in roi_points_overview),
                'y_min': min(p[1] for p in roi_points_overview),
                'y_max': max(p[1] for p in roi_points_overview)
            }
            
            roi_bounds_plane = {
                'u_min': min(p[0] for p in roi_points_plane),
                'u_max': max(p[0] for p in roi_points_plane),
                'v_min': min(p[1] for p in roi_points_plane),
                'v_max': max(p[1] for p in roi_points_plane)
            }
            
            # Save ROI visualization
            self.save_roi_visualization(overview_path, roi_points_overview, painting_name)
            
            # Create ROI selection data
            roi_data = {
                'painting_name': painting_name,
                'overview_image': str(overview_path),
                'roi_points_overview': roi_points_overview,
                'roi_points_plane': roi_points_plane,
                'roi_bounds_overview': roi_bounds_overview,
                'roi_bounds_plane': roi_bounds_plane,
                'grid_bounds': grid_bounds,
                'overview_size': overview_size,
                'timestamp': datetime.now().isoformat()
            }
            
            roi_selections[painting_name] = roi_data
            
            # Save intermediate results
            self.save_result(f"roi_selections_{painting_name}", roi_data)
            
            print(f"[OK] ROI selection completed for {painting_name}")
            print(f"  Overview bounds: {roi_bounds_overview}")
            print(f"  Plane bounds: {roi_bounds_plane}")
        
        # Save combined results
        step_results = {
            'roi_selections': roi_selections,
            'num_paintings': len(roi_selections),
            'timestamp': datetime.now().isoformat()
        }
        
        self.save_result("step6_roi_selection_results", step_results)
        
        successful_selections = sum(1 for data in roi_selections.values() if data.get('status') != 'placeholder')
        print(f"[OK] Step 6 completed. ROI selections for {len(roi_selections)} paintings ({successful_selections} successful).")
        
        return step_results


if __name__ == "__main__":
    # Test the step independently
    step = ManualROISelectionStep()
    results = step.run()
    if results:
        print(f"Step 6 completed. ROI selections for {results['num_paintings']} paintings.") 