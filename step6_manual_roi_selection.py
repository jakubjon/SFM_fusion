"""
Step 6: Manual ROI selection with proper coordinate system conversion
"""

import cv2
import numpy as np
from pathlib import Path
from datetime import datetime
from step_base import StepBase
import config
from camera_utils import PlaneProjector


class ManualROISelectionStep(StepBase):
    """Step 6: Manual ROI selection with proper coordinate conversion"""
    
    def __init__(self, photos_dir=config.PHOTOS_DIR, output_dir=config.OUTPUT_DIR):
        super().__init__(output_dir)
        self.photos_dir = Path(photos_dir)
        self.painting_sets = [d for d in self.photos_dir.iterdir() if d.is_dir()]
        self.rectified_dir = self.output_dir / 'rectified'
        self.roi_dir = self.output_dir / 'roi_selections'
        self.roi_dir.mkdir(exist_ok=True)
        
        # Mouse callback variables
        self.drawing = False
        self.start_point = None
        self.end_point = None
        self.roi_points = []
    
    def get_input_requirements(self):
        """Return required inputs for this step"""
        return [
            "step5_rectification_results"
        ]
    
    def get_output_files(self):
        """Return output files generated by this step"""
        outputs = []
        # We'll determine the painting names from the input
        outputs.extend([
            "intermediate/roi_selections_*.json",
            "intermediate/step6_roi_selection_results.json"
        ])
        return outputs
    
    def mouse_callback(self, event, x, y, flags, param):
        """Mouse callback for ROI selection"""
        if event == cv2.EVENT_LBUTTONDOWN:
            self.drawing = True
            self.start_point = (x, y)
            self.roi_points = [(x, y)]
        elif event == cv2.EVENT_MOUSEMOVE:
            if self.drawing:
                self.end_point = (x, y)
        elif event == cv2.EVENT_LBUTTONUP:
            self.drawing = False
            self.end_point = (x, y)
            self.roi_points.append((x, y))
    
    def select_roi_interactive(self, image_path, painting_name):
        """Interactive ROI selection for a painting overview"""
        # Load the overview image
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"Could not load overview image: {image_path}")
            return None
        
        # Create window and set mouse callback
        window_name = f"ROI Selection - {painting_name}"
        cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)
        cv2.setMouseCallback(window_name, self.mouse_callback)
        
        # Reset variables
        self.drawing = False
        self.start_point = None
        self.end_point = None
        self.roi_points = []
        
        print(f"\nROI Selection for {painting_name}")
        print("Instructions:")
        print("1. Click and drag to select a rectangular ROI")
        print("2. Press 'r' to reset selection")
        print("3. Press 's' to save selection")
        print("4. Press 'q' to quit without saving")
        print("5. Press 'ESC' to skip this painting")
        
        while True:
            # Create a copy of the image for drawing
            display_img = img.copy()
            
            # Draw current selection
            if self.start_point and self.end_point:
                cv2.rectangle(display_img, self.start_point, self.end_point, (0, 255, 0), 2)
            
            # Draw saved ROI points
            for i, point in enumerate(self.roi_points):
                cv2.circle(display_img, point, 3, (255, 0, 0), -1)
                if i > 0:
                    cv2.line(display_img, self.roi_points[i-1], point, (255, 0, 0), 2)
            
            cv2.imshow(window_name, display_img)
            key = cv2.waitKey(1) & 0xFF
            
            if key == ord('r'):  # Reset
                self.start_point = None
                self.end_point = None
                self.roi_points = []
                print("Selection reset")
            elif key == ord('s'):  # Save
                if len(self.roi_points) >= 2:
                    cv2.destroyWindow(window_name)
                    return self.roi_points
                else:
                    print("Please select at least 2 points for ROI")
            elif key == ord('q'):  # Quit
                cv2.destroyWindow(window_name)
                return None
            elif key == 27:  # ESC
                cv2.destroyWindow(window_name)
                return None
    
    def select_roi_automatic(self, image_path, painting_name):
        """Automatic ROI selection based on painting bounds"""
        # Load the overview image
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"Could not load overview image: {image_path}")
            return None
        
        # Get image dimensions
        height, width = img.shape[:2]
        
        # Create a polygon ROI that follows the painting shape
        # Use a more complex shape instead of just a rectangle
        margin = 20  # Margin from edges
        
        # Create a polygon with more points to define a proper shape
        roi_points = [
            (margin, margin),  # Top-left
            (width - margin, margin),  # Top-right
            (width - margin, height - margin),  # Bottom-right
            (margin, height - margin),  # Bottom-left
        ]
        
        # Add some intermediate points to make it more interesting
        # This creates a shape that's not just rectangular
        roi_points = [
            (margin, margin),  # Top-left
            (width // 3, margin),  # Top-left third
            (2 * width // 3, margin),  # Top-right third
            (width - margin, margin),  # Top-right
            (width - margin, height // 3),  # Right-top third
            (width - margin, 2 * height // 3),  # Right-bottom third
            (width - margin, height - margin),  # Bottom-right
            (2 * width // 3, height - margin),  # Bottom-right third
            (width // 3, height - margin),  # Bottom-left third
            (margin, height - margin),  # Bottom-left
            (margin, 2 * height // 3),  # Left-bottom third
            (margin, height // 3),  # Left-top third
        ]
        
        print(f"Created polygon ROI with {len(roi_points)} points")
        
        # Save ROI visualization
        self.save_roi_visualization(image_path, roi_points, painting_name)
        
        return roi_points
    
    def convert_roi_to_plane_coordinates(self, roi_points, grid_bounds, overview_size):
        """
        Convert ROI from overview image pixels to painting plane coordinates
        
        Args:
            roi_points: ROI points in overview image pixels
            grid_bounds: Grid bounds from rectification
            overview_size: Size of overview image (width, height)
            
        Returns:
            ROI points in painting plane coordinates (u, v)
        """
        if not roi_points or not grid_bounds:
            return None
        
        # Extract grid bounds
        min_u = grid_bounds['min_u']
        max_u = grid_bounds['max_u']
        min_v = grid_bounds['min_v']
        max_v = grid_bounds['max_v']
        grid_size = grid_bounds['grid_size']
        
        # Overview image size
        overview_width, overview_height = overview_size
        
        # Convert each ROI point
        plane_roi_points = []
        for point in roi_points:
            x, y = point
            
            # Map from overview image coordinates to grid coordinates
            grid_x = (x / overview_width) * grid_size
            grid_y = (y / overview_height) * grid_size
            
            # Map from grid coordinates to plane coordinates
            u = min_u + (grid_x / (grid_size - 1)) * (max_u - min_u)
            v = min_v + (grid_y / (grid_size - 1)) * (max_v - min_v)
            
            plane_roi_points.append([u, v])
        
        return plane_roi_points
    
    def save_roi_visualization(self, image_path, roi_points, painting_name):
        """Save ROI visualization image"""
        img = cv2.imread(str(image_path))
        if img is None:
            return
        
        # Draw ROI on image
        if len(roi_points) >= 2:
            # Draw points
            for i, point in enumerate(roi_points):
                cv2.circle(img, point, 5, (0, 255, 0), -1)
                if i > 0:
                    cv2.line(img, roi_points[i-1], point, (0, 255, 0), 2)
            
            # Close the polygon
            if len(roi_points) > 2:
                cv2.line(img, roi_points[-1], roi_points[0], (0, 255, 0), 2)
        
        # Save visualization
        vis_path = self.roi_dir / f"{painting_name}_roi_visualization.jpg"
        cv2.imwrite(str(vis_path), img)
        print(f"ROI visualization saved: {vis_path.name}")
    
    def run(self, **kwargs):
        """
        Allow manual ROI selection with proper coordinate conversion.
        
        Returns:
            dict: Results containing ROI selections for each painting
        """
        self.log_step("Step 6: Manual ROI selection with coordinate conversion")
        
        # Load rectification results from Step 5
        step5_results = self.load_result("step5_rectification_results")
        if not step5_results:
            print("[ERROR] Step 5 results not found. Please run Step 5 first.")
            return None
        
        rectification_results = step5_results.get('rectification_results', {})
        
        if not rectification_results:
            print("[ERROR] No rectification results found in Step 5 results.")
            return None
        
        roi_selections = {}
        
        for painting_name, rectification_data in rectification_results.items():
            print(f"\n{'='*80}")
            print(f"ROI Selection for painting {painting_name}")
            print(f"{'='*80}")
            
            # Check if we already have ROI selection
            existing_result = self.load_result(f"roi_selections_{painting_name}")
            if existing_result and config.INTERMEDIATE_RESULTS['save_intermediate'] and not self.should_overwrite_existing():
                print(f"Found existing ROI selection for {painting_name}")
                roi_selections[painting_name] = existing_result
                continue
            
            # Get overview image path
            overview_image = rectification_data.get('overview_image')
            if not overview_image:
                print(f"[WARNING] No overview image found for {painting_name}, creating placeholder ROI")
                # Create placeholder ROI data for failed rectification
                roi_data = {
                    'painting_name': painting_name,
                    'overview_image': None,
                    'roi_points_overview': [[0, 0], [100, 0], [100, 100], [0, 100]],  # Default 100x100 ROI
                    'roi_points_plane': [[0, 0], [1, 0], [1, 1], [0, 1]],  # Default plane coordinates
                    'roi_bounds_overview': {'x_min': 0, 'x_max': 100, 'y_min': 0, 'y_max': 100},
                    'roi_bounds_plane': {'u_min': 0, 'u_max': 1, 'v_min': 0, 'v_max': 1},
                    'status': 'placeholder',
                    'timestamp': datetime.now().isoformat()
                }
                roi_selections[painting_name] = roi_data
                self.save_result(f"roi_selections_{painting_name}", roi_data)
                print(f"[WARNING] Created placeholder ROI for {painting_name}")
                continue
            
            overview_path = Path(overview_image)
            if not overview_path.exists():
                print(f"[WARNING] Overview image not found: {overview_path}, creating placeholder ROI")
                # Create placeholder ROI data for missing overview
                roi_data = {
                    'painting_name': painting_name,
                    'overview_image': str(overview_path),
                    'roi_points_overview': [[0, 0], [100, 0], [100, 100], [0, 100]],  # Default 100x100 ROI
                    'roi_points_plane': [[0, 0], [1, 0], [1, 1], [0, 1]],  # Default plane coordinates
                    'roi_bounds_overview': {'x_min': 0, 'x_max': 100, 'y_min': 0, 'y_max': 100},
                    'roi_bounds_plane': {'u_min': 0, 'u_max': 1, 'v_min': 0, 'v_max': 1},
                    'status': 'placeholder',
                    'timestamp': datetime.now().isoformat()
                }
                roi_selections[painting_name] = roi_data
                self.save_result(f"roi_selections_{painting_name}", roi_data)
                print(f"[WARNING] Created placeholder ROI for {painting_name}")
                continue
            
            # Use automatic polygon ROI selection for shape-aware rectification
            roi_points_overview = self.select_roi_automatic(overview_path, painting_name)
            
            if roi_points_overview is None:
                print(f"[ERROR] Failed to select ROI for {painting_name}")
                continue
            
            # Get overview image size
            overview_img = cv2.imread(str(overview_path))
            overview_size = (overview_img.shape[1], overview_img.shape[0])  # width, height
            
            # Get grid bounds from rectification data
            grid_bounds = rectification_data.get('grid_bounds')
            
            # Convert ROI to painting plane coordinates
            roi_points_plane = self.convert_roi_to_plane_coordinates(
                roi_points_overview, grid_bounds, overview_size
            )
            
            if roi_points_plane is None:
                print(f"[ERROR] Failed to convert ROI coordinates for {painting_name}")
                continue
            
            # Calculate bounds in both coordinate systems
            roi_bounds_overview = {
                'x_min': min(p[0] for p in roi_points_overview),
                'x_max': max(p[0] for p in roi_points_overview),
                'y_min': min(p[1] for p in roi_points_overview),
                'y_max': max(p[1] for p in roi_points_overview)
            }
            
            roi_bounds_plane = {
                'u_min': min(p[0] for p in roi_points_plane),
                'u_max': max(p[0] for p in roi_points_plane),
                'v_min': min(p[1] for p in roi_points_plane),
                'v_max': max(p[1] for p in roi_points_plane)
            }
            
            # Save ROI visualization
            self.save_roi_visualization(overview_path, roi_points_overview, painting_name)
            
            # Create ROI selection data
            roi_data = {
                'painting_name': painting_name,
                'overview_image': str(overview_path),
                'roi_points_overview': roi_points_overview,
                'roi_points_plane': roi_points_plane,
                'roi_bounds_overview': roi_bounds_overview,
                'roi_bounds_plane': roi_bounds_plane,
                'grid_bounds': grid_bounds,
                'overview_size': overview_size,
                'timestamp': datetime.now().isoformat()
            }
            
            roi_selections[painting_name] = roi_data
            
            # Save intermediate results
            self.save_result(f"roi_selections_{painting_name}", roi_data)
            
            print(f"[OK] ROI selection completed for {painting_name}")
            print(f"  Overview bounds: {roi_bounds_overview}")
            print(f"  Plane bounds: {roi_bounds_plane}")
        
        # Save combined results
        step_results = {
            'roi_selections': roi_selections,
            'num_paintings': len(roi_selections),
            'timestamp': datetime.now().isoformat()
        }
        
        self.save_result("step6_roi_selection_results", step_results)
        
        successful_selections = sum(1 for data in roi_selections.values() if data.get('status') != 'placeholder')
        print(f"[OK] Step 6 completed. ROI selections for {len(roi_selections)} paintings ({successful_selections} successful).")
        
        return step_results


if __name__ == "__main__":
    # Test the step independently
    step = ManualROISelectionStep()
    results = step.run()
    if results:
        print(f"Step 6 completed. ROI selections for {results['num_paintings']} paintings.") 