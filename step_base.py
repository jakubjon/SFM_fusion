"""
Base class for all processing steps in the painting reconstruction pipeline.
Each step should inherit from this class and implement the required methods.
"""

import json
import os
from pathlib import Path
from datetime import datetime
from abc import ABC, abstractmethod
import numpy as np
import config


class StepBase(ABC):
    """Base class for all processing steps"""
    
    def __init__(self, output_dir=config.OUTPUT_DIR):
        self.output_dir = Path(output_dir)
        self.intermediate_dir = self.output_dir / 'intermediate'
        self.intermediate_dir.mkdir(parents=True, exist_ok=True)
        
    @abstractmethod
    def run(self, **kwargs):
        """
        Main execution method for the step.
        Should return a dictionary with step results.
        """
        pass
    
    @abstractmethod
    def get_input_requirements(self):
        """
        Return a list of required input files/data for this step.
        """
        pass
    
    @abstractmethod
    def get_output_files(self):
        """
        Return a list of output files generated by this step.
        """
        pass
    
    def save_result(self, step_name, data):
        """Save step result to intermediate directory"""
        if not config.INTERMEDIATE_RESULTS['save_intermediate']:
            return
        
        # Convert data to serializable format
        serializable_data = self.to_serializable(data)
        
        # Save as JSON
        result_path = self.intermediate_dir / f"{step_name}.json"
        with open(result_path, 'w') as f:
            json.dump(serializable_data, f, indent=2)
        
        print(f"Saved step result: {result_path.name}")
    
    def load_result(self, step_name):
        """Load step result from intermediate directory"""
        result_path = self.intermediate_dir / f"{step_name}.json"
        
        if result_path.exists():
            try:
                with open(result_path, 'r') as f:
                    return json.load(f)
            except (json.JSONDecodeError, FileNotFoundError) as e:
                print(f"Error loading step result {step_name}: {e}")
                return None
        else:
            print(f"Step result not found: {result_path}")
            return None
    
    def check_prerequisites(self, required_results):
        """Check if all required results from previous steps are available"""
        missing_results = []
        for result_name in required_results:
            if not self.load_result(result_name):
                missing_results.append(result_name)
        
        if missing_results:
            print(f"Missing required results: {missing_results}")
            return False
        
        return True
    
    def to_serializable(self, val):
        """Convert data to JSON-serializable format"""
        if isinstance(val, np.ndarray):
            return val.tolist()
        if isinstance(val, dict):
            return {k: self.to_serializable(v) for k, v in val.items()}
        if isinstance(val, list):
            return [self.to_serializable(v) for v in val]
        if isinstance(val, Path):
            return str(val)
        # Handle pycolmap specific types
        if hasattr(val, '__class__') and 'CameraModelId' in str(val.__class__):
            return str(val)
        if hasattr(val, '__class__') and 'CameraModel' in str(val.__class__):
            return str(val)
        # Handle pycolmap Camera objects
        if hasattr(val, '__class__') and 'Camera' in str(val.__class__):
            try:
                return {
                    'width': val.width,
                    'height': val.height,
                    'params': val.params.tolist() if hasattr(val.params, 'tolist') else list(val.params),
                    'model': str(val.model)
                }
            except Exception as e:
                print(f"Error serializing Camera object: {e}")
                return str(val)
        return val
    
    def log_step(self, step_name, painting_name=None):
        """Log a step with timestamp and painting name if applicable"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        if painting_name:
            print(f"\n## {timestamp} - {step_name} - Painting: {painting_name}")
        else:
            print(f"\n## {timestamp} - {step_name}")
        print("=" * 80) 

    def should_skip_step(self, step_name):
        """Check if a step should be skipped based on configuration"""
        if not config.EXECUTION_CONTROL['force_recalculation']:
            # Check if step result already exists
            result_path = self.intermediate_dir / f"{step_name}.json"
            if result_path.exists():
                print(f"Found existing result for {step_name}, skipping...")
                return True
        return False
    
    def should_overwrite_existing(self):
        """Check if existing data should be overwritten"""
        return config.EXECUTION_CONTROL['overwrite_existing'] 