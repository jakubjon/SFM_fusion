"""
Step 4: Point cloud generation for each individual painting batch with global calibration
"""

import numpy as np
from pathlib import Path
from datetime import datetime
import pycolmap
from step_base import StepBase
import config


class PointCloudGenerationStep(StepBase):
    """Step 4: Point cloud generation with global calibration"""
    
    def __init__(self, output_dir=config.OUTPUT_DIR):
        super().__init__(output_dir)
        self.point_cloud_dir = self.output_dir / 'point_clouds'
        self.point_cloud_dir.mkdir(exist_ok=True)
    
    def get_input_requirements(self):
        """Return required inputs for this step"""
        return [
            "step3_recalculate_positions_results"
        ]
    
    def get_output_files(self):
        """Return output files generated by this step"""
        outputs = []
        # We'll determine the painting names from the input
        outputs.extend([
            "intermediate/point_cloud_data_*.json",
            "intermediate/step4_point_cloud_results.json"
        ])
        return outputs
    
    def find_painting_plane(self, points3D):
        """Find the painting plane using RANSAC"""
        print("Finding painting plane...")
        
        if len(points3D) < 10:
            print("Not enough 3D points for plane fitting")
            return np.array([0, 0, 1]), np.array([0, 0, 0])
        
        points3D = np.array(points3D)
        print(f"Using {len(points3D)} 3D points for plane fitting")

        # Use RANSAC to find the dominant plane
        best_normal = None
        best_center = None
        max_inliers = 0
        
        for _ in range(config.RANSAC_ITERATIONS):
            # Sample 3 points
            idx = np.random.choice(len(points3D), 3, replace=False)
            p1, p2, p3 = points3D[idx]
            
            # Calculate plane normal
            v1 = p2 - p1
            v2 = p3 - p1
            normal = np.cross(v1, v2)
            normal = normal / np.linalg.norm(normal)
            
            # Calculate distance to plane
            center = (p1 + p2 + p3) / 3
            distances = np.abs(np.dot(points3D - center, normal))
            
            # Count inliers
            inliers = np.sum(distances < config.PLANE_THRESHOLD)
            
            if inliers > max_inliers:
                max_inliers = inliers
                best_normal = normal
                best_center = center
        
        print(f"Found plane with {max_inliers} inliers")
        return best_normal, best_center
    
    def analyze_point_cloud(self, points3D, painting_name):
        """Analyze point cloud and extract painting plane information"""
        self.log_step("Point cloud analysis", painting_name)
        
        # Convert points to numpy array
        points = []
        for point3D in points3D.values():
            points.append(point3D.xyz)
        
        if len(points) < 10:
            print(f"[ERROR] Not enough 3D points for {painting_name}")
            return None
        
        points = np.array(points)
        
        # Find painting plane
        plane_normal, plane_center = self.find_painting_plane(points)
        
        # Calculate point cloud statistics
        point_cloud_stats = {
            'num_points': len(points),
            'bounds': {
                'min': points.min(axis=0).tolist(),
                'max': points.max(axis=0).tolist(),
                'center': points.mean(axis=0).tolist()
            },
            'plane_normal': plane_normal.tolist(),
            'plane_center': plane_center.tolist(),
            'painting_name': painting_name
        }
        
        # Calculate distances to plane
        distances_to_plane = np.abs(np.dot(points - plane_center, plane_normal))
        point_cloud_stats['plane_fitting'] = {
            'mean_distance': float(np.mean(distances_to_plane)),
            'std_distance': float(np.std(distances_to_plane)),
            'max_distance': float(np.max(distances_to_plane)),
            'inlier_ratio': float(np.sum(distances_to_plane < config.PLANE_THRESHOLD) / len(points))
        }
        
        print(f"Point cloud analysis for {painting_name}:")
        print(f"  Points: {len(points)}")
        print(f"  Plane normal: [{plane_normal[0]:.3f}, {plane_normal[1]:.3f}, {plane_normal[2]:.3f}]")
        print(f"  Plane center: [{plane_center[0]:.3f}, {plane_center[1]:.3f}, {plane_center[2]:.3f}]")
        print(f"  Inlier ratio: {point_cloud_stats['plane_fitting']['inlier_ratio']:.3f}")
        
        return point_cloud_stats
    
    def save_point_cloud_visualization(self, points3D, painting_name, plane_normal, plane_center):
        """Save point cloud visualization (optional)"""
        try:
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d import Axes3D
            
            # Convert points to numpy array
            points = np.array([point3D.xyz for point3D in points3D.values()])
            
            # Create 3D plot
            fig = plt.figure(figsize=(12, 8))
            ax = fig.add_subplot(111, projection='3d')
            
            # Plot points
            ax.scatter(points[:, 0], points[:, 1], points[:, 2], c='b', alpha=0.6, s=1)
            
            # Plot plane center
            ax.scatter([plane_center[0]], [plane_center[1]], [plane_center[2]], 
                      c='r', s=100, marker='o')
            
            # Plot plane normal
            normal_end = plane_center + plane_normal * 0.1
            ax.quiver(plane_center[0], plane_center[1], plane_center[2],
                     plane_normal[0], plane_normal[1], plane_normal[2],
                     color='g', arrow_length_ratio=0.1)
            
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')
            ax.set_title(f'Point Cloud - {painting_name}')
            
            # Save plot
            plot_path = self.point_cloud_dir / f"{painting_name}_point_cloud.png"
            plt.savefig(plot_path, dpi=150, bbox_inches='tight')
            plt.close()
            
            print(f"Point cloud visualization saved: {plot_path.name}")
            
        except ImportError:
            print("matplotlib not available, skipping point cloud visualization")
        except Exception as e:
            print(f"Error creating point cloud visualization: {e}")
    
    def run(self, **kwargs):
        """
        Generate point clouds for each painting with global calibration.
        
        Returns:
            dict: Results containing point cloud data for each painting
        """
        self.log_step("Step 4: Point cloud generation with global calibration")
        
        # Load global reconstructions from Step 3
        step3_results = self.load_result("step3_recalculate_positions_results")
        if not step3_results:
            print("[ERROR] Step 3 results not found. Please run Step 3 first.")
            return None
        
        global_reconstructions = step3_results.get('global_reconstructions', {})
        global_camera_params = step3_results.get('global_camera_params')
        
        if not global_reconstructions:
            print("[ERROR] No global reconstructions found in Step 3 results.")
            return None
        
        point_cloud_data = {}
        
        for painting_name, reconstruction_data in global_reconstructions.items():
            print(f"\n{'='*80}")
            print(f"Generating point cloud for painting {painting_name}")
            print(f"{'='*80}")
            
            
            # Load the actual COLMAP reconstruction to get 3D points
            reconstruction_path = self.output_dir / painting_name / 'global' / '0'
            if not reconstruction_path.exists():
                print(f"[ERROR] COLMAP reconstruction not found for {painting_name}")
                continue
            
            try:
                # Load the reconstruction
                reconstruction = pycolmap.Reconstruction(str(reconstruction_path))
                points3D = reconstruction.points3D
                
                if len(points3D) < 10:
                    print(f"[ERROR] Not enough 3D points for {painting_name}")
                    continue
                
                # Analyze point cloud and find painting plane
                point_cloud_stats = self.analyze_point_cloud(points3D, painting_name)
                
                if point_cloud_stats is None:
                    print(f"[ERROR] Failed to analyze point cloud for {painting_name}")
                    continue
                
                # Create point cloud data with plane parameters
                point_cloud_summary = {
                    'painting_name': painting_name,
                    'num_points3D': len(points3D),
                    'global_camera_params': global_camera_params,
                    'reconstruction_summary': {
                        'num_cameras': len(reconstruction_data.get('cameras', {})),
                        'num_images': len(reconstruction_data.get('images', {})),
                        'num_points3D': len(points3D)
                    },
                    'timestamp': datetime.now().isoformat(),
                    'plane_data': {
                        'plane_normal': point_cloud_stats['plane_normal'],
                        'plane_center': point_cloud_stats['plane_center'],
                        'inlier_ratio': point_cloud_stats['plane_fitting']['inlier_ratio'],
                        'mean_distance': point_cloud_stats['plane_fitting']['mean_distance']
                    }
                }
                
                point_cloud_data[painting_name] = point_cloud_summary
                
                # Save intermediate results

                self.save_result(f"point_cloud_data_{painting_name}", point_cloud_summary)
                
                print(f"[OK] Point cloud data generated for {painting_name}")
                
            except Exception as e:
                print(f"[ERROR] Failed to process point cloud for {painting_name}: {e}")
                continue
        
        # Save combined results
        step_results = {
            'point_cloud_data': point_cloud_data,
            'global_camera_params': global_camera_params,
            'num_paintings': len(point_cloud_data),
            'timestamp': datetime.now().isoformat()
        }
        
        self.save_result("step4_point_cloud_results", step_results)
        
        print(f"[OK] Step 4 completed. Generated point clouds for {len(point_cloud_data)} paintings.")
        
        return step_results


if __name__ == "__main__":
    # Test the step independently
    step = PointCloudGenerationStep()
    results = step.run()
    if results:
        print(f"Step 4 completed. Generated point clouds for {results['num_paintings']} paintings.") 